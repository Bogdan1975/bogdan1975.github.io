/**
 * Created by Targus on 28.04.2016.
 * @author Bogdan Shapoval (targus) <it.targus@gmail.com>
 */

declare var hljs: any;

import {Component, Input, ElementRef, ContentChildren, QueryList, QueryMetadata} from 'angular2/core'
import {Ng2StyledDirective, IStyledConfig, ISkinable} from 'ng2-styled-directive/ng2-styled.directive'

@Component({
    selector: 'show-code',
    template: '<div styled stylePath="{{stylePath}}"><ng-content></ng-content></div>',
    directives: [Ng2StyledDirective],
})
export class Ng2ShowCodeComponent implements ISkinable {
    
    @Input() language = 'html';
    @Input() skin:string = 'github';
    @Input() skinDirectory:string = 'node_modules/highlightjs/styles';

    @ContentChildren(Ng2StyledDirective) _children:QueryList<Ng2StyledDirective>;
    // @ContentChildren(Ng2StyledDirective) _children2:QueryMetadata<Ng2StyledDirective>;

    private hljs;

    // private _skinDirectory:string = 'node_modules/highlightjs/styles';
    private _skinNames:Array<string> = ['agate', 'androidstudio', 'arta', 'ascetic', 'atelier-cave.dark', 'atelier-cave.light', 'atelier-dune.dark', 'atelier-dune.light', 'atelier-estuary.dark', 'atelier-estuary.light', 'atelier-forest.dark', 'atelier-forest.light', 'atelier-heath.dark', 'atelier-heath.light', 'atelier-lakeside.dark', 'atelier-lakeside.light', 'atelier-plateau.dark', 'atelier-plateau.light', 'atelier-savanna.dark', 'atelier-savanna.light', 'atelier-seaside.dark', 'atelier-seaside.light', 'atelier-sulphurpool.dark', 'atelier-sulphurpool.light', 'brown_paper', 'codepen-embed', 'color-brewer', 'dark', 'darkula', 'default', 'docco', 'far', 'foundation', 'github-gist', 'github', 'googlecode', 'grayscale', 'hopscotch', 'hybrid', 'idea', 'ir_black', 'kimbie.dark', 'kimbie.light', 'magula', 'mono-blue', 'monokai', 'monokai_sublime', 'obsidian', 'paraiso.dark', 'paraiso.light', 'pojoaque', 'railscasts', 'rainbow', 'school_book', 'solarized_dark', 'solarized_light', 'sunburst', 'tomorrow-night-blue', 'tomorrow-night-bright', 'tomorrow-night-eighties', 'tomorrow-night', 'tomorrow', 'vs', 'xcode', 'zenburn'];
    public stylePath:string;

    constructor(private _elementRef: ElementRef){
        this.hljs = typeof(hljs) == 'object' ? hljs : null;
    }

    ngAfterContentInit() {
        if ((<any>this._skinNames).includes(this.skin)) {
            this.stylePath = `${this.skinDirectory}/${this.skin}.css`
        }
        // in case of some code was marked as CDATA
        // var tmplt = this._elementRef.nativeElement.children[0].innerHTML.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
        var tmplt = this.decodeEntities(this._elementRef.nativeElement.children[0].innerHTML); 
        if (this.hljs != null && typeof(this.hljs)=='object' && typeof(this.hljs.highlight)=='function') {
            tmplt = this.hljs.highlight(this.language, tmplt, true).value;
        } else {
            tmplt = this.reformatCode(tmplt);
        }
        this._elementRef.nativeElement.innerHTML = `<pre><code class="html">${tmplt}</code></pre>`;
    }

    decodeEntities(encodedString) {
        let textArea = document.createElement('textarea');
        textArea.innerHTML = encodedString;
        return textArea.value;
    }

    reformatCode(code:string):string {
        return this.reformatHtml(code);
    }

    reformatHtml(code:string):string {
        return code.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    getIdentityAttribute() {
        for (let attr of this._elementRef.nativeElement.attributes) {
            if (/^_nghost/.test(attr.name) || /^_ngcontent/.test(attr.name)) {
                return attr.name;
            }
        }
        return false;
    }

    setStyleForElement(style: string) {
        let idAttr = this.getIdentityAttribute();
        var styleEl = document.createElement('style');
        styleEl.type = 'text/css';
        var styleString = `[${idAttr}] ${style}`;
        styleEl.innerHTML = styleString;
        var head  = document.getElementsByTagName('head')[0];
        head.appendChild(styleEl);
    }

    // create configuration for using skins by "styled" directive
    // Implementation of ISkinable interface
    getStyledConfig():IStyledConfig {
        var config:IStyledConfig = {};
        this._skinNames.forEach((value) => {
            config[value] = {
                'path': `${this.skinDirectory}/${value}.css`
            }
        });
        return config;
    }
}

